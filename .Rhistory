devtools::build()
devtools::install()
devtools::check()
library(hww4)
library(hw4)
?square
library(h24)
library(hw4)
?square
usethis::use_vignette("tutorial")
wine <- read.csv("/Users/gracebosma/Desktop/winequality-red.csv", sep = ';')[1:50,]
save(wine, file="data/wine.RData")
attr(wine, "pH")
attr(wine, pH)
attr(wine, wine$fixed.acidity)
attr(wine, fixed.acidity)
data(wine)
wine$pH
usethis::use_vignette("tutorial")
#'lm2
#'
#'Used fit linear regression models
#'
#'@param formula an object of class "formula" that models regression to be fit
#'
#'@param data data frame to perform the linear regression on
#'
#'@param na.action character input that determines how the regression model should handle missing data. Options include 'omit' (remove rows with NA values), 'fail'(halt regression), or 'mean impute' (replace NA values with column mean)
#'
#'@return a list that contains the following values: residuals, rank, fitted.values, df.residual, coefficients, call, model, data.frame, cf, y
#'
#'@export
lm2 <- function(formula, data, na.action = 'omit'){
#obtain indexes of which columns / covariates to keep
covariates <- all.vars(formula)
index <- rep(0,length(covariates))
for (i in 1:length(covariates)){
index[i] <- which(colnames(data) == covariates[i])
}
data <- data[,index]
# Handle missing values
if (anyNA(data) == TRUE){
if (na.action == 'omit'){
data <- na.omit(data)
} else if (na.action == 'fail'){
stop("Dataset contains missing values.")
} else if (na.action == 'mean impute'){
for(i in 1:ncol(data)){
data[is.na(data[,i]), i] <- mean(data[,i], na.rm = TRUE)
}
}
}
y <- as.matrix(data[,which(colnames(data) == all.vars(formula)[1])])
x <- model.matrix(formula, data = data)
n <- nrow(x)
p <- ncol(x)
# Betas
colnames(x)[1] <- '(Intercept)'
betas <- solve(t(x) %*% x) %*% t(x) %*% y
fitted <- as.vector(as.vector(x %*% betas))
names(fitted) <- 1:nrow(x)
# Variance & Residuals
resid <- as.vector(y - x %*% betas)
names(resid) <- c(1:nrow(x))
SSyy=sum((y-mean(y))^2)
SSE=sum(resid^2)
s <- sqrt( SSE/(n-p))
ses <- sqrt(diag(solve(t(x) %*% x)))*s
# T scores and P-values
tscores <- betas / ses
pvalues <- 2*pt(abs(tscores),length(y) - ncol(x),lower.tail=FALSE)
coefs <- data.frame("Estimate" = betas, "Std. Error" = ses,
"t value" = tscores, "Pr(>|t|)" = pvalues, check.names = FALSE)
call <- noquote(paste(c('lm(', formula, ')'), collapse = ''))
output <- list(resid, nrow(betas), fitted, n-p, betas[,1], call, data, x, coefs, y)
names(output) <- c("residuals", "rank", "fitted.values", "df.residual", "coefficients", "call", "model", "data.frame", "cf", "y")
class(output) <- "lm2"
UseMethod("print.lm2")
return(output)
}
#'@rdname print
#'@method print.lm2
#'@export
print.lm2 <- function(m){
cat("Call: ", m$call, ' ', "Coefficients: ", sep = '\n')
print(m$coefficients)
}
lm2 <- function(formula, data, na.action = 'omit'){
#obtain indexes of which columns / covariates to keep
covariates <- all.vars(formula)
index <- rep(0,length(covariates))
for (i in 1:length(covariates)){
index[i] <- which(colnames(data) == covariates[i])
}
data <- data[,index]
# Handle missing values
if (anyNA(data) == TRUE){
if (na.action == 'omit'){
data <- na.omit(data)
} else if (na.action == 'fail'){
stop("Dataset contains missing values.")
} else if (na.action == 'mean impute'){
for(i in 1:ncol(data)){
data[is.na(data[,i]), i] <- mean(data[,i], na.rm = TRUE)
}
}
}
y <- as.matrix(data[,which(colnames(data) == all.vars(formula)[1])])
x <- model.matrix(formula, data = data)
n <- nrow(x)
p <- ncol(x)
# Betas
colnames(x)[1] <- '(Intercept)'
betas <- solve(t(x) %*% x) %*% t(x) %*% y
fitted <- as.vector(as.vector(x %*% betas))
names(fitted) <- 1:nrow(x)
# Variance & Residuals
resid <- as.vector(y - x %*% betas)
names(resid) <- c(1:nrow(x))
SSyy=sum((y-mean(y))^2)
SSE=sum(resid^2)
s <- sqrt( SSE/(n-p))
ses <- sqrt(diag(solve(t(x) %*% x)))*s
# T scores and P-values
tscores <- betas / ses
pvalues <- 2*pt(abs(tscores),length(y) - ncol(x),lower.tail=FALSE)
coefs <- data.frame("Estimate" = betas, "Std. Error" = ses,
"t value" = tscores, "Pr(>|t|)" = pvalues, check.names = FALSE)
call <- noquote(paste(c('lm(', formula, ')'), collapse = ''))
output <- list(resid, nrow(betas), fitted, n-p, betas[,1], call, data, x, coefs, y)
names(output) <- c("residuals", "rank", "fitted.values", "df.residual", "coefficients", "call", "model", "data.frame", "cf", "y")
class(output) <- "lm2"
cat("Call: ", call, ' ', "Coefficients: ", sep = '\n')
print(betas[,1])
return(invisible(output))
}
print.summarylm2 <- function(sumoutput){
pvalues <- as.vector(sumoutput$coefficients[,4])
sig <- ifelse (pvalues <0.001, '***',
ifelse (pvalues <0.01, '** ',
ifelse(pvalues < 0.05, '*  ',
ifelse(pvalues < 0.1, '.  ', ''))))
cat("Call: ", sumoutput$call, ' ',  "Residuals: ", sep = '\n')
print(sumoutput$residuals)
cat(" ", "Coefficients: \n")
print(cbind(sumoutput$coefficients, sig))
cat("---\n")
sig.codes <- "Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1"
msg <- paste(c("Residual standard error: ", sumoutput$s, " on ", sumoutput$df[2], " degrees of freedom \nMultiple R-Squared: ",
sumoutput$r.squared, ", Adjusted R-squared: ", sumoutput$adj.r.squared, "\nF-Statistic: ", sumoutput$fstat, " on ", sumoutput$df[3], " and ", sumoutput$df[2],
" DF, p-value: ", sumoutput$F.pval), collapse = '')
cat(msg)
}
return(invisible(sumoutput))
